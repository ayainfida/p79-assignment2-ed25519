error[invalid-return-type]: Function can implicitly return `None`, which is not assignable to return type `Point | ExtendedPoint`
 --> ed25519/methods.py:3:58
  |
1 | from .point import ExtendedPoint, Point
2 |
3 | def double_and_add(k: int, Pt: Point | ExtendedPoint) -> Point | ExtendedPoint:
  |                                                          ^^^^^^^^^^^^^^^^^^^^^
4 |     """
5 |     Perform scalar multiplication using the double-and-add method.
  |
info: rule `invalid-return-type` is enabled by default

error[unsupported-operator]: Unsupported `+` operation
  --> ed25519/methods.py:25:20
   |
23 |         result = double_and_add((k - 1) // 2, Pt).double()
24 |         if (isinstance(result, ExtendedPoint) and isinstance(Pt, ExtendedPoint)) or (isinstance(result, Point) and isinstance(Pt, Poin…
25 |             return result + Pt
   |                    ------^^^--
   |                    |
   |                    Both operands have type `ExtendedPoint | Point`
26 |     
27 | # if __name__ == "__main__":
   |
info: rule `unsupported-operator` is enabled by default

error[invalid-argument-type]: Argument to bound method `derive_public_key` is incorrect
  --> tests/test_api.py:38:53
   |
36 |         # 1) derive_public_key should only accept PrivateKey objects, and raise TypeError if it is not given a PrivateKey
37 |         with self.assertRaises(TypeError):
38 |             self.ed25519_instance.derive_public_key("not a private key")
   |                                                     ^^^^^^^^^^^^^^^^^^^ Expected `PrivateKey`, found `Literal["not a private key"]`
39 |         with self.assertRaises(TypeError):
40 |             self.ed25519_instance.derive_public_key(PublicKey(b'\x22' * 32))
   |
info: Method defined here
  --> ed25519/ed25519.py:51:9
   |
49 |         return PrivateKey(key_bytes=sk)
50 |
51 |     def derive_public_key(self, sk: PrivateKey) -> PublicKey:
   |         ^^^^^^^^^^^^^^^^^       -------------- Parameter declared here
52 |         """
53 |         Derive the public key from the given private key.
   |
info: Union variant `bound method ED25519.derive_public_key(sk: PrivateKey) -> PublicKey` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.derive_public_key(sk: PrivateKey) -> PublicKey)`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `derive_public_key` is incorrect
  --> tests/test_api.py:40:53
   |
38 |             self.ed25519_instance.derive_public_key("not a private key")
39 |         with self.assertRaises(TypeError):
40 |             self.ed25519_instance.derive_public_key(PublicKey(b'\x22' * 32))
   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^ Expected `PrivateKey`, found `PublicKey`
41 |         with self.assertRaises(TypeError):
42 |             self.ed25519_instance.derive_public_key(urandom(32))
   |
info: Method defined here
  --> ed25519/ed25519.py:51:9
   |
49 |         return PrivateKey(key_bytes=sk)
50 |
51 |     def derive_public_key(self, sk: PrivateKey) -> PublicKey:
   |         ^^^^^^^^^^^^^^^^^       -------------- Parameter declared here
52 |         """
53 |         Derive the public key from the given private key.
   |
info: Union variant `bound method ED25519.derive_public_key(sk: PrivateKey) -> PublicKey` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.derive_public_key(sk: PrivateKey) -> PublicKey)`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `derive_public_key` is incorrect
  --> tests/test_api.py:42:53
   |
40 |             self.ed25519_instance.derive_public_key(PublicKey(b'\x22' * 32))
41 |         with self.assertRaises(TypeError):
42 |             self.ed25519_instance.derive_public_key(urandom(32))
   |                                                     ^^^^^^^^^^^ Expected `PrivateKey`, found `bytes`
43 |         # Valid instance should not raise
44 |         self.ed25519_instance.derive_public_key(PrivateKey(b'\x00' * 32)) 
   |
info: Method defined here
  --> ed25519/ed25519.py:51:9
   |
49 |         return PrivateKey(key_bytes=sk)
50 |
51 |     def derive_public_key(self, sk: PrivateKey) -> PublicKey:
   |         ^^^^^^^^^^^^^^^^^       -------------- Parameter declared here
52 |         """
53 |         Derive the public key from the given private key.
   |
info: Union variant `bound method ED25519.derive_public_key(sk: PrivateKey) -> PublicKey` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.derive_public_key(sk: PrivateKey) -> PublicKey)`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `sign` is incorrect
  --> tests/test_api.py:48:66
   |
46 | …or if sk is not a PrivateKey
47 | …or):
48 | …(Message(b"test message"), "not a private key")
   |                             ^^^^^^^^^^^^^^^^^^^ Expected `PrivateKey`, found `Literal["not a private key"]`
49 | …or):
50 | …(Message(b"test message"), self.ed25519_instance.derive_public_key(self.ed25519_instance.generate_private_key()))
   |
info: Method defined here
  --> ed25519/ed25519.py:75:9
   |
73 |         return PublicKey(point_compression(self.scalar_mult(secret_scalar, self.base_point)))
74 |     
75 |     def sign(self, message: Message, sk: PrivateKey) -> Signature:
   |         ^^^^                         -------------- Parameter declared here
76 |         """
77 |         Sign a message using the given private key.
   |
info: Union variant `bound method ED25519.sign(message: Message, sk: PrivateKey) -> Signature` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.sign(message: Message, sk: PrivateKey) -> Signature)`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `sign` is incorrect
  --> tests/test_api.py:50:66
   |
48 | …(b"test message"), "not a private key")
49 | …
50 | …(b"test message"), self.ed25519_instance.derive_public_key(self.ed25519_instance.generate_private_key()))
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `PrivateKey`, found `Unknown | PublicKey`
51 | …
52 | …(b"test message"), urandom(32))
   |
info: Element `PublicKey` of this union is not assignable to `PrivateKey`
info: Method defined here
  --> ed25519/ed25519.py:75:9
   |
73 |         return PublicKey(point_compression(self.scalar_mult(secret_scalar, self.base_point)))
74 |     
75 |     def sign(self, message: Message, sk: PrivateKey) -> Signature:
   |         ^^^^                         -------------- Parameter declared here
76 |         """
77 |         Sign a message using the given private key.
   |
info: Union variant `bound method ED25519.sign(message: Message, sk: PrivateKey) -> Signature` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.sign(message: Message, sk: PrivateKey) -> Signature)`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `sign` is incorrect
  --> tests/test_api.py:52:66
   |
50 | …         self.ed25519_instance.sign(Message(b"test message"), self.ed25519_instance.derive_public_key(self.ed25519_instance.generate_…
51 | …     with self.assertRaises(TypeError):
52 | …         self.ed25519_instance.sign(Message(b"test message"), urandom(32))
   |                                                                ^^^^^^^^^^^ Expected `PrivateKey`, found `bytes`
53 | …     # Valid instance should not raise
54 | …     self.ed25519_instance.sign(Message(b"test message"), self.ed25519_instance.generate_private_key())
   |
info: Method defined here
  --> ed25519/ed25519.py:75:9
   |
73 |         return PublicKey(point_compression(self.scalar_mult(secret_scalar, self.base_point)))
74 |     
75 |     def sign(self, message: Message, sk: PrivateKey) -> Signature:
   |         ^^^^                         -------------- Parameter declared here
76 |         """
77 |         Sign a message using the given private key.
   |
info: Union variant `bound method ED25519.sign(message: Message, sk: PrivateKey) -> Signature` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.sign(message: Message, sk: PrivateKey) -> Signature)`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `verify` is incorrect
  --> tests/test_api.py:62:58
   |
60 |         signature = self.ed25519_instance.sign(msg, sk)
61 |         with self.assertRaises(TypeError):
62 |             self.ed25519_instance.verify(msg, signature, "not a public key")
   |                                                          ^^^^^^^^^^^^^^^^^^ Expected `PublicKey`, found `Literal["not a public key"]`
63 |         with self.assertRaises(TypeError):
64 |             self.ed25519_instance.verify(msg, signature, self.ed25519_instance.generate_private_key())
   |
info: Method defined here
   --> ed25519/ed25519.py:115:9
    |
113 |         return signature
114 |     
115 |     def verify(self, message: Message, signature: Signature, pk: PublicKey) -> bool:
    |         ^^^^^^                                               ------------- Parameter declared here
116 |         """
117 |         Verify a signature for a given message and public key.
    |
info: Union variant `bound method ED25519.verify(message: Message, signature: Signature, pk: PublicKey) -> bool` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.verify(message: Message, signature: Signature, pk: PublicKey) -> bool)`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `verify` is incorrect
  --> tests/test_api.py:64:58
   |
62 |             self.ed25519_instance.verify(msg, signature, "not a public key")
63 |         with self.assertRaises(TypeError):
64 |             self.ed25519_instance.verify(msg, signature, self.ed25519_instance.generate_private_key())
   |                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `PublicKey`, found `Unknown | PrivateKey`
65 |         with self.assertRaises(TypeError):
66 |             self.ed25519_instance.verify(msg, signature, urandom(32))
   |
info: Element `PrivateKey` of this union is not assignable to `PublicKey`
info: Method defined here
   --> ed25519/ed25519.py:115:9
    |
113 |         return signature
114 |     
115 |     def verify(self, message: Message, signature: Signature, pk: PublicKey) -> bool:
    |         ^^^^^^                                               ------------- Parameter declared here
116 |         """
117 |         Verify a signature for a given message and public key.
    |
info: Union variant `bound method ED25519.verify(message: Message, signature: Signature, pk: PublicKey) -> bool` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.verify(message: Message, signature: Signature, pk: PublicKey) -> bool)`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `verify` is incorrect
  --> tests/test_api.py:66:58
   |
64 |             self.ed25519_instance.verify(msg, signature, self.ed25519_instance.generate_private_key())
65 |         with self.assertRaises(TypeError):
66 |             self.ed25519_instance.verify(msg, signature, urandom(32))
   |                                                          ^^^^^^^^^^^ Expected `PublicKey`, found `bytes`
67 |         # Valid instance should not raise
68 |         self.assertTrue(self.ed25519_instance.verify(msg, signature, pk))
   |
info: Method defined here
   --> ed25519/ed25519.py:115:9
    |
113 |         return signature
114 |     
115 |     def verify(self, message: Message, signature: Signature, pk: PublicKey) -> bool:
    |         ^^^^^^                                               ------------- Parameter declared here
116 |         """
117 |         Verify a signature for a given message and public key.
    |
info: Union variant `bound method ED25519.verify(message: Message, signature: Signature, pk: PublicKey) -> bool` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ED25519.verify(message: Message, signature: Signature, pk: PublicKey) -> bool)`
info: rule `invalid-argument-type` is enabled by default

error[missing-argument]: No argument provided for required parameter `sign` of bound method `__init__`
  --> tests/test_encoding.py:24:18
   |
22 |         for y in test_values:
23 |             # x is automatically calculated from y and the sign, so we only need to specify y and the parity of x
24 |             Pt = Point(y=FieldElement(y), is_odd=random.choice([True, False]))
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |             encoded = point_compression(Pt)
26 |             decoded = point_decompression(encoded)
   |
info: Parameter declared here
  --> ed25519/point.py:10:41
   |
 8 | @dataclass
 9 | class Point:
10 |     def __init__(self, y: FieldElement, sign: int, x: FieldElement | None = None):
   |                                         ^^^^^^^^^
11 |         """
12 |         Initialize a point on the Edwards curve defined by the equation:
   |
info: rule `missing-argument` is enabled by default

error[unknown-argument]: Argument `is_odd` does not match any known parameter of bound method `__init__`
  --> tests/test_encoding.py:24:43
   |
22 |         for y in test_values:
23 |             # x is automatically calculated from y and the sign, so we only need to specify y and the parity of x
24 |             Pt = Point(y=FieldElement(y), is_odd=random.choice([True, False]))
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |             encoded = point_compression(Pt)
26 |             decoded = point_decompression(encoded)
   |
info: Method signature here
  --> ed25519/point.py:10:9
   |
 8 | @dataclass
 9 | class Point:
10 |     def __init__(self, y: FieldElement, sign: int, x: FieldElement | None = None):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 |         """
12 |         Initialize a point on the Edwards curve defined by the equation:
   |
info: rule `unknown-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `sign` of bound method `__init__`
  --> tests/test_group_law.py:12:19
   |
10 | class TestGroupLaw(unittest.TestCase):
11 |     def setUp(self):
12 |         self.Pt = Point(y=BASE_Y, is_odd=BASE_X_SIGN)
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |         self.ExtendedPt = self.Pt.to_extended_coordinates()
   |
info: Parameter declared here
  --> ed25519/point.py:10:41
   |
 8 | @dataclass
 9 | class Point:
10 |     def __init__(self, y: FieldElement, sign: int, x: FieldElement | None = None):
   |                                         ^^^^^^^^^
11 |         """
12 |         Initialize a point on the Edwards curve defined by the equation:
   |
info: rule `missing-argument` is enabled by default

error[unknown-argument]: Argument `is_odd` does not match any known parameter of bound method `__init__`
  --> tests/test_group_law.py:12:35
   |
10 | class TestGroupLaw(unittest.TestCase):
11 |     def setUp(self):
12 |         self.Pt = Point(y=BASE_Y, is_odd=BASE_X_SIGN)
   |                                   ^^^^^^^^^^^^^^^^^^
13 |         self.ExtendedPt = self.Pt.to_extended_coordinates()
   |
info: Method signature here
  --> ed25519/point.py:10:9
   |
 8 | @dataclass
 9 | class Point:
10 |     def __init__(self, y: FieldElement, sign: int, x: FieldElement | None = None):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 |         """
12 |         Initialize a point on the Edwards curve defined by the equation:
   |
info: rule `unknown-argument` is enabled by default

error[invalid-argument-type]: Argument to bound method `_set_test_metadata` is incorrect
  --> tests/test_wyche_proof_vectors.py:53:52
   |
51 |                 expected = (t["result"] == "valid")
52 |
53 |                 metadata = self._set_test_metadata(sk=None, pk=pk, msg=msg, sig=sig, result=expected)
   |                                                    ^^^^^^^ Expected `PrivateKey`, found `None`
54 |
55 |                 self._test_vector(metadata, ed25519_instance)
   |
info: Method defined here
  --> tests/test_wyche_proof_vectors.py:17:9
   |
15 |     Helper method to set up test metadata for a given test case.
16 |     """
17 |     def _set_test_metadata(self, sk: PrivateKey, pk: PublicKey, msg: Message, sig: Signature, result: bool) -> dict:
   |         ^^^^^^^^^^^^^^^^^^       -------------- Parameter declared here
18 |         return {
19 |             'pk': pk,
   |
info: rule `invalid-argument-type` is enabled by default

Found 16 diagnostics
